`include "defines.sv"

module processing_element(

    // Clock and Reset Inputs
    input wire clk,
    input wire rst_n,

    // Input Instruction
    input pe_inst_t     pe_inst,
    input logic         pe_inst_valid,

    // Input Operands
    input logic [`PE_INPUT_BITWIDTH-1:0] vector_input,
    input logic [`PE_INPUT_BITWIDTH-1:0] matrix_input,

    // Output Operand
    output logic [`PE_OUTPUT_BITWIDTH-1:0] vector_output


);

    // START IMPLEMENTATION
    logic [`PE_OPCODE_BITWIDTH-1:0] opcode;
    logic [`PE_MODE_BITWIDTH-1:0] mode;
    logic [`PE_VALUE_BITWIDTH-1:0] value;

    logic [`PE_ACCUMULATION_BITWIDTH-1:0] acc_value;
    logic [`PE_ACCUMULATION_BITWIDTH-1:0] next_acc_value;
    logic [`PE_ACCUMULATION_BITWIDTH - 1:0] temp_val;
    logic [`PE_OUTPUT_BITWIDTH-1:0] next_output_value;
    logic [`PE_ACCUMULATION_BITWIDTH - 1:0] lane;

    int mode_bitwidth;
    int num_channels;
    int output_channel_width;
    int vacc_width;

    always @* begin
        next_output_value = vector_output;
        next_acc_value = acc_value;

        if (pe_inst_valid) begin
            opcode = pe_inst.opcode;
            mode = pe_inst.mode;
            value = pe_inst.value;

            case (opcode) 
                `PE_RND_OPCODE: begin
                    case (mode)
                        2'd0: begin
                            for (int i = 0; i < 4; i++) begin
                                lane = acc_value[i * `PE_ACCUMULATION_BITWIDTH/4 +: `PE_ACCUMULATION_BITWIDTH/4];
                                shifted = lane >> value;
                                next_acc_value[i * `PE_ACCUMULATION_BITWIDTH/4 +: `PE_ACCUMULATION_BITWIDTH/4] = shifted[0 +: `PE_ACCUMULATION_BITWIDTH/4];
                            end
                        end
                        2'd1: begin
                            for (int i = 0; i < 2; i++) begin
                                lane = acc_value[i * `PE_ACCUMULATION_BITWIDTH/2 +: `PE_ACCUMULATION_BITWIDTH/2];
                                shifted = lane >> value;
                                next_acc_value[i * `PE_ACCUMULATION_BITWIDTH/2 +: `PE_ACCUMULATION_BITWIDTH/2] = shifted[0 +: `PE_ACCUMULATION_BITWIDTH/2];
                            end
                        end
                        default: begin
                            shifted = acc_value >> value;
                            next_acc_value = shifted;
                        end
                    endcase
                end   
                default: begin
                    case (value) 
                        `PE_MAC_VALUE: begin
                            for (int i = 0; i < num_channels; i++) begin
                                logic [`PE_INPUT_BITWIDTH - 1:0] a_val = vector_input[i * mode_bitwidth +: mode_bitwidth];
                                logic [`PE_INPUT_BITWIDTH - 1:0] b_val = matrix_input[i * mode_bitwidth +: mode_bitwidth];
                                temp_val[0 +: vacc_width] = acc_value[i * vacc_width +: vacc_width];

                                logic [`PE_ACCUMULATION_BITWIDTH - 1:0] final_val = temp_val + a_val * b_val;
                                logic [`PE_ACCUMULATION_BITWIDTH - 1:0] wrapped = final_val & ((1 << vacc_width) - 1);

                                next_acc_value[i * vacc_width +: vacc_width] = wrapped[0 +: vacc_width];
                            end
                        end
                        `PE_OUT_VALUE: begin
                            for (int i = 0; i < num_channels; i++) begin
                                logic [`PE_ACCUMULATION_BITWIDTH - 1:0] vacc_lane_val = acc_value[i * vacc_width +: vacc_width];
                                next_output_value[i * output_channel_width +: output_channel_width] = vacc_lane_val[0 +: output_channel_width];
                            end
                        end
                        `PE_PASS_VALUE: begin
                            for (int i = 0; i < num_channels; i++) begin
                                logic [`PE_INPUT_BITWIDTH - 1:0] lane_value = vector_input[i * mode_bitwidth +: mode_bitwidth];
                                next_acc_value[i * vacc_width +: vacc_width] = lane_value[0 +: mode_bitwidth];
                            end
                        end
                        `PE_CLR_VALUE: begin
                            next_acc_value = '0;
                            next_output_value = '0;
                        end
                        default: begin
                            // NOP
                        end
                    endcase
                end
            endcase
        end
    end

    always_ff @(posedge clk) begin
        if (!rst_n) begin
            acc_value <= '0; // sets all bits to 0!
            vector_output <= '0;
        end else begin
            acc_value <= next_acc_value;
            vector_output <= next_output_value;
        end
    end
    // END IMPLEMENTATION

endmodule
